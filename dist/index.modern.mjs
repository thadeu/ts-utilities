function n(){return n=Object.assign?Object.assign.bind():function(n){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var o in r)Object.prototype.hasOwnProperty.call(r,o)&&(n[o]=r[o])}return n},n.apply(this,arguments)}class t extends Error{constructor(n,t){super(n),this.statusCode=void 0,this.name="TryException",this.statusCode=t||400,Error.captureStackTrace(this,this.constructor)}}const r=n=>{var t;return"Function"===(null==n||null==(t=n.constructor)?void 0:t.name)},o=n=>{var t;return"AsyncFunction"===(null==n||null==(t=n.constructor)?void 0:t.name)},e=n=>{var t;return"RegExp"===(null==(t=n.constructor)?void 0:t.name)},u=n=>"string"==typeof n&&n.trim(),l=(n,t=null)=>o(n)||r(n)?n(t):n,i=n=>new Promise((t,r)=>setTimeout(t,n)),c=(n,...t)=>{const r=new Promise((t,r)=>{setTimeout(()=>r(`limit time excedded (${n} ms)`),n)});return Promise.race([r,...t])};function s(e,u){var a,v,d;const m=null!=(a=null==u?void 0:u.max)?a:0,y=null!=(v=null==u?void 0:u.async)?v:o(e);let p=null!=(d=null==u?void 0:u.count)?d:0;try{var h;return y?c(null!=(h=null==u?void 0:u.timeout)?h:9999,l(e)).catch(t=>p>=m?null!=u&&u.onError?l(null==u?void 0:u.onError,t):t:(p++,null!=u&&u.onRetry&&u.onRetry(p,p>=m),m>0?async function(t){return await i(p**(null!=(t=null==u?void 0:u.exponential)?t:.5)*1e3),s(e,n({},u,{count:p}))}():s(e,n({},u,{count:p})))):(r(e),l(e))}catch(r){if(p>=m){if(null!=u&&u.strict)throw new t(r);return l(null==u?void 0:u.onError,r)}return p++,null!=u&&u.onRetry&&u.onRetry(p,p>=m),m>0?async function(t){return await i(p**(null!=(t=null==u?void 0:u.exponential)?t:.5)*1e3),s(e,n({},u,{count:p}))}():s(e,n({},u,{count:p}))}}export{l as Execute,s as Try,i as delay,o as isAsyncFunction,r as isFunction,e as isPlainRegex,u as isPlainString,c as race};
//# sourceMappingURL=index.modern.mjs.map
